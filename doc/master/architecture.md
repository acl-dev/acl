# ACL Master 架构设计

## 概述

ACL Master 框架是一个灵活、高效的服务器开发框架，提供了多种服务器模型以适应不同的应用场景。本文档详细介绍 Master 框架的架构设计、工作原理和最佳实践。

## 整体架构

### 框架层次结构

```
┌─────────────────────────────────────────────────────────┐
│                   用户应用层                              │
│   (继承 master_* 类并实现业务逻辑)                        │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                  Master 框架层                           │
│  ┌──────────┬──────────┬──────────┬──────────┐          │
│  │master_   │master_   │master_   │master_   │          │
│  │threads   │proc      │aio       │udp/      │          │
│  │          │          │          │trigger   │          │
│  └──────────┴──────────┴──────────┴──────────┘          │
│               ↑                                          │
│         ┌─────┴─────┐                                    │
│         │master_base│   ← ← ← master_conf               │
│         └───────────┘                                    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│              ACL 核心库层                                │
│  ┌──────────────────┬─────────────────────────┐         │
│  │网络 I/O          │事件驱动                  │         │
│  │(socket, stream)  │(event, aio_handle)      │         │
│  └──────────────────┴─────────────────────────┘         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│               操作系统层                                 │
│   (Linux/FreeBSD/MacOS/Windows)                         │
└─────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. master_base（基础框架）

`master_base` 是所有服务器模型的抽象基类，提供了：

#### 核心功能
- **配置管理**: 统一的配置参数加载和管理机制
- **生命周期管理**: 标准化的初始化和销毁流程
- **事件管理**: 进程级定时器支持
- **监听管理**: 多地址监听支持

#### 生命周期

```
启动
  ↓
proc_on_listen (每个监听地址)
  ↓
proc_pre_jail (root 权限)
  ↓
[切换用户权限]
  ↓
proc_on_init (普通用户权限)
  ↓
[运行主循环]
  ↓
[收到退出信号]
  ↓
proc_pre_exit (可以延迟退出)
  ↓
proc_on_exit
  ↓
退出
```

### 2. master_threads（线程池模型）

#### 架构设计

```
               监听套接字
                   ↓
              [accept队列]
                   ↓
           ┌───────────────┐
           │  线程池管理器  │
           └───────────────┘
                   ↓
     ┌──────┬──────┼──────┬──────┐
     ↓      ↓      ↓      ↓      ↓
   线程1  线程2  线程3  线程4  线程N
     ↓      ↓      ↓      ↓      ↓
   连接1  连接2  连接3  连接4  连接N
```

#### 工作流程

1. **监听阶段**: 主线程监听端口，接受连接
2. **分发阶段**: 将新连接分发到线程池的任务队列
3. **处理阶段**: 工作线程从队列取出任务，处理连接
4. **读取阶段**: 线程读取客户端数据并处理
5. **关闭阶段**: 连接处理完成或超时后关闭

#### 线程安全

- 每个连接只由一个线程处理
- 使用互斥锁保护共享资源
- 提供 `thread_enable_read`/`thread_disable_read` 控制读取状态

#### 适用场景

- **长连接服务**: 如聊天服务器、游戏服务器
- **中等并发**: 并发连接数在几千到几万
- **有状态连接**: 需要维护连接状态

### 3. master_proc（多进程模型）

#### 架构设计

```
              acl_master
                  ↓
       [进程池管理和监控]
                  ↓
    ┌──────┬──────┼──────┬──────┐
    ↓      ↓      ↓      ↓      ↓
  进程1  进程2  进程3  进程4  进程N
    ↓      ↓      ↓      ↓      ↓
  连接1  连接2  连接3  连接4  连接N
    ↓
  [处理]
    ↓
  [退出]
```

#### 工作流程

1. **预创建**: acl_master 预先创建多个子进程
2. **监听**: 所有子进程共享监听套接字
3. **接受**: 子进程竞争接受新连接（惊群由内核处理）
4. **处理**: 子进程处理完连接后退出或继续接受新连接
5. **回收**: 父进程回收退出的子进程并创建新进程

#### 进程隔离优势

- **稳定性**: 单个进程崩溃不影响其他进程
- **简单性**: 无需考虑线程同步问题
- **安全性**: 进程间天然隔离

#### 适用场景

- **高稳定性要求**: 金融、支付等关键业务
- **CPU 密集型**: 大量计算任务
- **进程隔离需求**: 需要严格的资源隔离

### 4. master_aio（异步 I/O 模型）

#### 架构设计

```
           事件循环 (Event Loop)
                  ↓
        ┌─────────────────────┐
        │   事件多路复用器      │
        │ (epoll/kqueue/IOCP) │
        └─────────────────────┘
                  ↓
     ┌────────────┼────────────┐
     ↓            ↓            ↓
  监听事件     读事件      写事件
     ↓            ↓            ↓
  accept      on_read      on_write
     ↓            ↓            ↓
  新连接       处理数据     发送数据
```

#### 工作流程

1. **初始化**: 创建事件句柄，注册监听套接字
2. **事件循环**: 等待事件发生
3. **连接到达**: 触发 accept 回调，创建异步流
4. **数据到达**: 触发读回调，处理业务逻辑
5. **异步写入**: 数据写入缓冲区，自动发送

#### 事件驱动模型

```cpp
while (running) {
    events = wait_events(timeout);
    for (event in events) {
        if (event.is_read()) {
            handle_read(event.stream);
        } else if (event.is_write()) {
            handle_write(event.stream);
        } else if (event.is_accept()) {
            handle_accept(event.stream);
        }
    }
}
```

#### 支持的事件引擎

| 引擎 | 操作系统 | 性能 | 特点 |
|------|---------|------|------|
| epoll | Linux | 高 | 大量连接时性能优秀 |
| kqueue | FreeBSD/MacOS | 高 | 效率高，功能强大 |
| IOCP | Windows | 高 | Windows 最优选择 |
| poll | 通用 | 中 | 兼容性好 |
| select | 通用 | 低 | 最大连接数受限 |

#### 适用场景

- **高并发**: 数万到数十万并发连接
- **长短连接均可**: HTTP 服务器、API 网关、WebSocket、长连接推送
- **低延迟**: 实时消息推送
- **I/O 密集型**: 代理服务器
- **熟悉异步编程**: 适合习惯事件驱动、回调风格的开发者

### 5. master_trigger（定时触发模型）

#### 架构设计

```
     启动
      ↓
    [初始化]
      ↓
   ┌─────┐
   │等待  │ ← ← ← ← ←
   └─────┘          ↑
      ↓             ↑
   [定时到达]       ↑
      ↓             ↑
  on_trigger()      ↑
      ↓             ↑
   [执行任务]       ↑
      ↓             ↑
   [sleep(间隔)]    ↑
      ↓ ← ← ← ← ← ← ↑
```

#### 适用场景

- **定时任务**: 日志清理、数据备份
- **周期性检查**: 健康检查、资源监控
- **批处理**: 批量数据处理

### 6. master_fiber（协程模型）

#### 架构设计

```
         监听套接字
              ↓
       [协程调度器]
              ↓
    ┌────────────────────┐
    │  协程池 (Fiber Pool) │
    └────────────────────┘
              ↓
   ┌──────┬──────┬──────┬──────┐
   ↓      ↓      ↓      ↓      ↓
 协程1  协程2  协程3  协程4  协程N
   ↓      ↓      ↓      ↓      ↓
 连接1  连接2  连接3  连接4  连接N
   ↓
 [同步编程]
   ↓
 [异步执行]
```

#### 工作流程

1. **初始化**: 创建协程调度器和线程池
2. **监听**: 主协程监听端口，接受连接
3. **创建协程**: 每个新连接创建一个独立协程
4. **协程调度**: 协程在 I/O 操作时自动让出 CPU
5. **数据处理**: 以同步方式编写代码，但异步执行
6. **连接关闭**: 协程结束，资源自动回收

#### 协程特性

**协程 vs 线程**:

| 特性 | 协程 | 线程 |
|------|------|------|
| 创建开销 | 小 | 较大 |
| 栈内存 | 较小 (默认128KB) | 较大 (1-8MB) |
| 切换开销 | 小（用户态） | 较大（内核态） |
| 并发数量 | 数万到数十万 | 数千 |
| 编程模型 | 同步写法 | 同步写法 |
| 调度方式 | 用户态调度 | 内核态调度 |

#### 协程调度机制

```cpp
// 协程1
read(socket);  // I/O 操作，让出 CPU
               ↓
            [调度器切换到协程2]
               ↓
// 协程2
write(socket); // I/O 操作，让出 CPU
               ↓
            [调度器切换到协程3]
               ↓
// 协程3
process();     // CPU 操作，继续执行
               ↓
// 当协程1的 I/O 就绪时，调度器自动切换回协程1
```

#### 适用场景

- **高并发**: 数万到数十万并发连接
- **I/O 密集型**: 大量网络 I/O 操作
- **长短连接均可**: HTTP 服务器、API 网关、WebSocket、长连接推送
- **微服务**: 代理服务器、网关服务
- **实时通信**: IM、推送服务
- **偏好同步编程**: 不想写异步回调，希望用同步方式编写代码

#### 优势

1. **简化编程**: 同步写法，逻辑清晰
2. **高性能**: 与异步 I/O 性能相当
3. **高并发**: 支持数万到数十万并发连接
4. **快速切换**: 用户态调度，无系统调用开销

### 7. master_udp（UDP 模型）

#### 架构设计

```
        UDP 监听套接字
              ↓
       ┌──────────────┐
       │ 接收数据报    │
       └──────────────┘
              ↓
       ┌──────────────┐
       │  线程池分发   │
       └──────────────┘
              ↓
    ┌────┬────┼────┬────┐
    ↓    ↓    ↓    ↓    ↓
  线程1 线程2 线程3 线程4 线程N
    ↓    ↓    ↓    ↓    ↓
  处理  处理  处理  处理  处理
    ↓    ↓    ↓    ↓    ↓
  响应  响应  响应  响应  响应
```

#### 工作流程

1. **绑定**: 绑定 UDP 端口
2. **接收**: 接收数据报
3. **分发**: 将数据报分发到线程池
4. **处理**: 工作线程处理数据
5. **响应**: 发送响应数据报

#### 适用场景

- **DNS 服务器**: 域名解析
- **日志收集**: syslog 服务器
- **实时通信**: 语音、视频传输
- **游戏服务器**: 实时对战

## 配置管理

### 配置系统架构

```
┌──────────────────┐
│  配置文件 (.cf)   │
└──────────────────┘
         ↓
┌──────────────────┐
│  master_conf     │
│  (配置解析器)     │
└──────────────────┘
         ↓
┌──────────────────┐      ┌──────────────┐
│ master_bool_tbl  │ ───→ │ bool 变量    │
├──────────────────┤      ├──────────────┤
│ master_int_tbl   │ ───→ │ int 变量     │
├──────────────────┤      ├──────────────┤
│ master_int64_tbl │ ───→ │ int64 变量   │
├──────────────────┤      ├──────────────┤
│ master_str_tbl   │ ───→ │ string 变量  │
└──────────────────┘      └──────────────┘
```

### 配置加载流程

1. **定义配置表**: 声明配置参数和目标变量
2. **注册配置表**: 调用 `set_cfg_*` 方法注册
3. **加载配置文件**: `run_daemon` 或 `run_alone` 时自动加载
4. **参数验证**: 验证参数范围和类型
5. **参数应用**: 将配置值赋给目标变量

## 运行模式

### Daemon 模式（生产环境）

```
┌──────────────────┐
│   acl_master     │  (守护进程管理器)
└──────────────────┘
         ↓
   [读取配置]
         ↓
   [fork 子进程]
         ↓
┌──────────────────┐
│  服务器进程       │
│  (master_* 实例) │
└──────────────────┘
         ↓
    [监听端口]
         ↓
    [处理请求]
```

#### acl_master 配置文件

```bash
# 服务名称
service_name

# 服务类型: inet (TCP), udp, unix, trigger
service_type = inet

# 监听地址
service_addr = 0.0.0.0:8080

# 进程数（对于多进程模型）
process_limit = 10

# 每个进程最大连接数
connection_limit = 100

# 应用程序路径
command = /path/to/server

# 其他参数...
```

### 独立模式（开发调试）

```
┌──────────────────┐
│  开发者启动       │
└──────────────────┘
         ↓
┌──────────────────┐
│  服务器进程       │
│  (master_* 实例) │
└──────────────────┘
         ↓
   run_alone(...)
         ↓
    [监听端口]
         ↓
    [处理请求]
         ↓
   [可调试、日志]
```

## 性能优化

### 线程池模型优化

1. **线程数量**: 通常设置为 CPU 核心数的 2-4 倍
2. **任务队列**: 监控 `task_qlen()` 实现流控
3. **连接超时**: 合理设置读写超时，及时释放资源
4. **内存池**: 使用 ACL 内存池减少内存分配开销

### 异步 I/O 模型优化

1. **选择合适的事件引擎**: Linux 用 epoll，FreeBSD 用 kqueue
2. **缓冲区大小**: 根据应用调整读写缓冲区
3. **批量操作**: 批量读取、批量写入减少系统调用
4. **定时器管理**: 合理使用定时器，避免过多定时器

### 进程模型优化

1. **进程数量**: 根据 CPU 核心数和负载调整
2. **进程复用**: 允许进程处理多个连接后再退出
3. **共享内存**: 使用共享内存在进程间共享数据

## 最佳实践

### 1. 模型选择

```
┌─────────────────────────────────────────┐
│           应用场景决策树                 │
└─────────────────────────────────────────┘
              开始
               ↓
        是否需要网络连接？
         ↙         ↘
       否            是
        ↓             ↓
   master_trigger  协议类型？
                  ↙        ↘
                UDP       TCP
                 ↓          ↓
             master_udp  并发量？
                        ↙        ↘
                      高         中低
                       ↓           ↓
                   编程偏好？    连接特性？
                  ↙      ↘      ↙      ↘
            同步风格  异步回调 长连接  稳定性优先
                ↓        ↓      ↓        ↓
          master_  master_ master_  master_
           fiber    aio   threads   proc
```

### 2. 错误处理

```cpp
// 在回调函数中捕获异常
virtual bool thread_on_read(socket_stream* stream) {
    try {
        // 业务逻辑
        return process_request(stream);
    } catch (const std::exception& e) {
        logger_error("处理错误: %s", e.what());
        return false; // 关闭连接
    }
}
```

### 3. 资源管理

```cpp
class my_server : public master_threads {
protected:
    virtual void proc_on_init() {
        // 初始化全局资源
        init_database_pool();
        init_cache_client();
    }
    
    virtual void thread_on_init() {
        // 初始化线程局部资源
        init_thread_local_buffer();
    }
    
    virtual void thread_on_exit() {
        // 清理线程资源
        cleanup_thread_local_buffer();
    }
    
    virtual void proc_on_exit() {
        // 清理全局资源
        cleanup_database_pool();
        cleanup_cache_client();
    }
};
```

### 4. 日志记录

```cpp
// 使用 ACL 日志系统
#include <acl_cpp/stdlib/log.hpp>

virtual bool thread_on_read(socket_stream* stream) {
    acl::logger("收到连接: %s", stream->get_peer());
    
    // 处理逻辑
    if (error) {
        acl::logger_error("处理失败: %s", error_msg);
        return false;
    }
    
    return true;
}
```

### 5. 优雅退出

```cpp
class my_server : public master_threads {
protected:
    virtual bool proc_pre_exit() {
        // 检查是否可以退出
        if (has_pending_tasks()) {
            logger("还有待处理任务，延迟退出");
            return false; // 延迟退出
        }
        return true; // 允许退出
    }
    
    virtual void proc_on_exit() {
        // 保存状态、清理资源
        save_state();
        cleanup_resources();
    }
};
```

## 安全考虑

### 1. 权限降级

```
启动 (root 权限)
    ↓
proc_pre_jail() - 执行需要 root 的操作
    ↓
[切换到普通用户]
    ↓
proc_on_init() - 普通用户权限运行
```

### 2. 资源限制

- 设置最大连接数限制
- 设置请求大小限制
- 设置超时时间
- 使用内存池防止内存泄漏

### 3. 输入验证

```cpp
virtual bool thread_on_read(socket_stream* stream) {
    char buf[4096];
    int ret = stream->read(buf, sizeof(buf) - 1);
    
    if (ret <= 0) {
        return false;
    }
    
    // 验证输入
    if (!validate_input(buf, ret)) {
        logger_warn("非法输入");
        return false;
    }
    
    // 处理
    return process(buf, ret);
}
```

## 调试技巧

### 1. 启用日志

```cpp
// 启用 master 框架日志
acl::master_log_enable(true);

// 设置 ACL 日志级别
acl::log::open("debug.log", "debug");
```

### 2. 独立模式调试

```cpp
int main(int argc, char* argv[]) {
#ifdef DEBUG
    my_server server;
    server.run_alone("127.0.0.1:8080", "test.cf");
#else
    my_server server;
    server.run_daemon(argc, argv);
#endif
    return 0;
}
```

### 3. 性能分析

- 使用 `task_qlen()` 监控线程池队列
- 记录请求处理时间
- 监控内存使用
- 使用 gprof/perf 等工具分析性能

## master_aio vs master_fiber 对比

两者都是高并发服务器模型，支持长连接和短连接，主要区别在于编程方式：

| 对比项 | master_aio | master_fiber |
|--------|-----------|--------------|
| 编程模型 | 异步回调（事件驱动） | 同步写法（协程） |
| 代码风格 | 回调函数链 | 顺序执行代码 |
| 并发能力 | 高（数万到数十万） | 高（数万到数十万） |
| 资源占用 | 低 | 低 |
| 学习曲线 | 需要理解异步编程 | 同步思维即可 |
| 调试难度 | 较难（回调链） | 简单（顺序逻辑） |
| 适合场景 | 熟悉异步编程的团队 | 偏好同步编程的团队 |

**示例对比**：

```cpp
// master_aio - 异步回调方式
class aio_handler : public acl::aio_callback {
    bool read_callback(char* data, int len) override {
        // 处理数据
        conn_->write(response, len, this);  // 异步写
        return true;
    }
    
    bool write_callback() override {
        // 写完成后继续读
        conn_->read(1024, 0, this);
        return true;
    }
};

// master_fiber - 同步方式（但异步执行）
void on_accept(acl::socket_stream& stream) override {
    char buf[1024];
    int ret = stream.read(buf, sizeof(buf), false);  // 看起来同步
    // 处理数据
    stream.write(response, len);  // 看起来同步
    // 代码按顺序执行，逻辑清晰
}
```

**选择建议**：
- 如果团队熟悉 Node.js、Nginx 等异步框架，选择 **master_aio**
- 如果希望用同步方式编写高并发代码，选择 **master_fiber**
- 两者性能相当，都能满足高并发需求

## 总结

ACL Master 框架提供了完整的服务器开发解决方案：

- **多样化**: 6 种服务器模型覆盖各种场景
- **灵活性**: 支持 daemon 和独立运行模式
- **可扩展**: 基于继承的设计便于扩展
- **高性能**: 针对不同场景优化的实现
- **易用性**: 清晰的 API 和完整的生命周期管理

选择合适的模型，遵循最佳实践，可以快速开发出高性能、高可靠的网络服务。

